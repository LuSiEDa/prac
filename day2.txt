# from import만 잔뜩 적어볼까?
from typing import List, Set

from pydantic import BaseModel, HttpUrl

from fastapi import Cookie, FastAPI, Header, status

List : 리스트안의 원소 타입 지정.  tags: list[str]
Set : 타입 힌팅용.
set → 마트 장바구니
Set[int] → “마트 장바구니인데, 사과(숫자)만 담아야 함”
즉, 실질적으로는 런타임엔 아무것도 안 하지만, 개발 과정에서 버그를 예방하는 데 강력한 스티커 역할

HttpUrl : 단순히 문자열(str)이 아니라, "HTTP 또는 HTTPS로 시작하는 URL"임을 보장하는 특수 타입.
예 https://example.com은 통과하지만, ftp://example.com이나 hello 같은 건 에러
 
Header: HTTP 요청에 담겨 오는 헤더 값을 FastAPI 함수에서 바로 받는 방법.
클라이언트가 요청할 때 보내는 Authorization, User-Agent, X-Request-ID 같은 헤더들을 바로 변수로 받을 수 있다.

 

status: 편집기의 오류 코드 자동완성 기능

 

# Pydantic 모델 자주 쓰는 메서드 몇 가지.
model_dump() : Pydantic 모델 → 딕셔너리(dict) 변환

model_dump_json() : Pydantic 모델 → JSON 문자열 변환

model_copy() : Pydantic 모델을 복사해서 새 인스턴스 만들기

model_validate() : dict나 다른 자료형을 모델 검증 후 인스턴스로 변환

model_json_schema() : 모델의 구조 → JSON 스키마 반환


# FastAPI에서 함수 인자로 자동으로 채워주는 값 4가지
 

경로 파라미터 {item_id}
 

쿼리 파라미터 ?skip=5     
함수 인자로 경로 파라미터에 없는 이름을 추가하면 FastAPI가 자동으로 "쿼리"에서 찾음

요청 바디 JSON → Pydantic 모델   
POST, PUT 같은 메서드에서 JSON 데이터를 보내면,
함수 인자에 **Pydantic 모델(BaseModel)**을 적어두면 자동으로 매핑

class Item(BaseModel):
    name: str
    price: float

@app.post("/items/")
async def create_item(item: Item):
    return {"name": item.name, "price": item.price}

요청 예:

{
  "name": "Book",
  "price": 9.99
}

item 인자에 Item(name="Book", price=9.99) 자동 변환

특별 객체(Request, Response, Header 등)
FastAPI는 몇 가지 특별한 타입을 함수 인자로 적어두면 자동으로 넣어줌.

from fastapi import Request, Response, Header, Cookie

@app.get("/headers")
async def get_headers(request: Request, user_agent: str = Header(None)):
    return {"ua": user_agent, "method": request.method}

 

Request → 전체 요청 객체
Response → 응답 조작 객체
Header, Cookie → 헤더/쿠키 값 자동 매핑
 # 본문 - 다중 매개변수
class Item(BaseModel):

    name: str

    description: Union[str, None] = None

    price: float tax: Union[float, None] = None

 

class User(BaseModel):

    username: str

    full_name: Union[str, None] = None

 

async def update_item(item_id: int, item: Item, user: User):

-> 이렇게 본문 매개변수를 복수로 만들 수 있지만 FastAPI는 헷갈려한다. 그러므로,

class UpdateRequest(BaseModel):
    item: Item
    user: User

@app.put("/items/{item_id}")
async def update_item(item_id: int, data: UpdateRequest):
와 같이 data: 로 처리한다.

 

 - 본문 내의 단일 값
기본자료형 -> 쿼리 파라미터로 간주.

BaseModel 상속 -> body로 간주.

async def update_item(item_id: int, item: Item, user: User, importance: int):

importance: int → 쿼리 파라미터로 취급됨 (기본형이니까)

만약 importance도 Body에 들어가길 원한다면 알려줘야 한다. 그게 Body() 함수의 역할이다.

async def update_item(
    item_id: int,
    item: Item,
    user: User,
    importance: int = Body(...)
):

 

 - 다중 본문 매개변수와 쿼리
“다중 본문 + 쿼리 매개변수 동시에 선언 가능( 어차피 Body와 Query는 서로 독립적으로 동작함)

 

 - 단일 본문 매개변수 삽입하기
기본: 모델이 단일 본문 매개변수면 그 자체가 JSON 루트가 됨.

embed=True 쓰면 항상 키가 생김:

async def update_item(item_id: int, item: Item = Body(embed=True)):

->

   {
  "item": {
    "name": "Foo",
    "price": 42.0
  }
}

------------------------------------------------------------------

 # 본문 - 필드
Field를 사용하여 모델 내에서 검증과 메타데이터를 선언할 수 있습니다.

 

 - field import
 

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = Field(
        default=None, title="The description of the item", max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results

 

! Field는 다른 것들처럼 (Query, Path, Body 등) fastapi에서가 아닌 pydantic에서 바로 임포트 되는 점에 주의하세요. !

 

 - 모델 어트리뷰트 선언
모델 어트리뷰트와 함께 Field를 사용할 수 있습니다:

class Item(BaseModel):
    name: str
    description: str | None = Field(
    default=None, title="The description of the item", max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: float | None = None
 

----------------------------------------------------------------------

# 본문 - 중첩 모델
리스트는 어트리뷰트를 서브타입으로 정의할  수 있다.

class User(BaseModel):
    tags: List[str]

list라고만 쓰지 않고 List[str]이라고 리스트에 들어갈 제약을 추가할 수 있다.

이것은 tags를 항목 리스트로 만든다. 각 항목에 타입을 선언하지 않아도 된다.

 

 - 타입 매개변수가 있는 리스트 필드
from typing import List

typing의 List 임포트로도 리스트에 타입을 선언할 수 있다. 형태는 위와 동일.

 

 - 중첩 모델
Pydantic 모델의 속성(어트리뷰트)은 단순한 str, int, list 같은 기본 타입뿐만 아니라, 또 다른 BaseModel을 타입으로 가질 수도 있다.

설명이 어려운데, 그냥 다른 모델을 끌고 올 수 있다.

class Image(BaseModel):
    url: str
    width: int
    height: int

class User(BaseModel):
    username: str
    image: Union[Image, None]  # 다른 모델을 필드로 포함

이를 통해 기대되는 것 : 중첩 모멜도 편집기 지원(자동 완성 등), 데이터 변환, 데이터 검증, 자동 문서화

 

 - 특별한 타입과 검증
from pydantic import BaseModel, HttpUrl

class Image(BaseModel):

    url: HttpUrl                -> 이렇게 url만 받겠다고 할 수도 있는거다.

 

 - 서브모델 리스트를 갖는 어트리뷰트
list, set 등의 서브타입으로 pydantic 모델을 사용할 수도 있다.

class Image(BaseModel):

    url: HttpUrl

    name: str

 

class Item(BaseModel):

    images: Union[List[Image], None] = None   -> Image 모델을 가져옴.

예상되는 Item에 JSON 본문:

"images" : [

        {

                 "url": "http://example.com/baz.jpg",

                 "name": "The Foo live"

         },

         {

                   "url": "http://example.com/dave.jpg",

                   "name": "The Baz"

          }

     ]

 

 - 좀 더 깊게 중첩된 본문
 

Offer
└─ items: List[Item] → 여러 개의 Item을 가진다.
Item
└─ images: Union[List[Image], None] → 여러 개의 Image를 가질 수도 있고(None일 수도 있음).
Image
└─ url: HttpUrl, name: str
{
  "name": "여름 세일",
  "description": "여름 특별 할인",
  "price": 99.99,
  "items": [   // 🔵 Offer 안에 Item 리스트
    {
      "name": "티셔츠",
      "price": 19.99,
      "tags": ["의류", "여름"],
      "images": [   // 🟢 Item 안에 Image 리스트
        {"url": "http://example.com/img1.jpg", "name": "앞면"},
        {"url": "http://example.com/img2.jpg", "name": "뒷면"}
      ]
    },
    {
      "name": "모자",
      "price": 9.99,
      "tags": ["액세서리"],
      "images": null   // 🟢 여기도 Image 자리인데 값이 없음(null)
    }
  ]
}

 - 순수 리스트의 본문
 

예상되는 JSON 본문의 최상위 값이 JSON array(파이썬 list)면, Pydantic 모델에서와 마찬가지로 함수의 매개변수에서 타입을 선언할 수 있습니다

-> 그러니까 함수에 매개변수에도 타입 지정된 리스트를 쓸 수 있다는 말.

async def create_multiple_images(images: List[Image]):

 

 - 단독 dict의 본문
일부 타입의 키와 다른 타입의 값을 이용하여 dict로 본문을 선언 할 수 있다.

유효한 필드/어트리뷰트 이름이 무엇인지 알 필요도 없이 지정하면 지정한 포맷대로 데이터를 가져온다.

async def create_index_weights(weights: Dict[int, float]):

JSON은 오직 str형 키만 지원함.  하지만 Pydamtic은 자동 데이터 변환이 있음.

int,float를 넣으면 알아서 int를 키로 인식해 변환하고 검증함.

 

---------------------------------------------------------------------------------------------

 

# 요청 예제 데이터 선언
model_config 안의 json_schema_extra를 사용하면 Pydantic 모델의 JSON 스키마에 예시 데이터를 추가

model_config = {
    "json_schema_extra": {
          "examples": [
             {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
              }
         ]
     }
}
examples는 여러개 설정할 수도 있다.

-> 결국 예시일뿐.

 

: 모델 안에서(Field(examples=[...]), 모델 전체(model_config = {"json_schema_extra": {"examples": [...]}})

body 매개변수에서 (Body(examples=[...])) 등등 예를 들어서 형식을 openAPI에서 가시적으로 알릴 수 있다는 말인듯. 이하 pass

 

----------------------------------------------------------------------------------------------------------------------

# 추가 데이터 자료형
일반적인 기본 자료형(int, float, str, bool) 외에 좀 더 복잡한 데이터 타입을 요청과 응답에서 다루는 방법.

 

UUID: 범용 고유 식별자, 요청/응답에서 문자열(str)로 처리
datetime.datetime / datetime.date / datetime.time: ISO 8601 형식 문자열로 요청/응답
datetime.timedelta: 시간 간격, 요청/응답에서 초(float)로 표현 가능
frozenset: 요청에서 리스트 → set, 응답에서 set → 리스트 변환, 중복 제거
bytes: 요청/응답에서 문자열로 처리, binary 형식 명시
Decimal: 고정 소수점, float와 유사하게 처리
start_process = start_datetime + process_after
duration = end_datetime - start_process

 

datetime과 timedelta를 조합해 계산 가능
FastAPI가 들어오는 요청 데이터를 올바른 Python 타입으로 변환해주므로, 연산 가능
------------------------------------------------------------------------------------------------------------------

 

# 쿠키 매개변수
HTTP 요청에 담겨 오는 쿠키 값을 FastAPI 함수에서 바로 받는 방법

브라우저나 클라이언트가 보내는 쿠키를 함수 매개변수로 선언하면, FastAPI가 자동으로 꺼내서 넣어줌.

from fastapi import Cookie, FastAPI

 

Path와 Query처럼 동일한 구조를 사용하는 쿠키 매개변수를 선언합니다.

첫 번째 값은 기본값이며, 추가 검증이나 어노테이션 매개변수 모두 전달할 수 있습니다:

async def read_items(ads_id: Annotated[str | None, Cookie()] = None):

Cookie는 Path 및 Query의 "자매"클래스입니다. 이 역시 동일한 공통 Param 클래스를 상속합니다.

쿠키를 선언하기 위해서는 Cookie를 사용해야 합니다. 그렇지 않으면 해당 매개변수를 쿼리 매개변수로 해석하기 때문입니다.

 

-------------------------------------------------------------------------------------------------------------------

# 헤더 매개변수
HTTP 요청에 담겨 오는 헤더 값을 FastAPI 함수에서 바로 받는 방법.

클라이언트가 요청할 때 보내는 Authorization, User-Agent, X-Request-ID 같은 헤더들을 바로 변수로 받을 수 있다.

async def read_items(user_agent: Union[str, None] = Header(default=None))

Header는 기본적으로 매개변수 이름을 언더스코어(_)에서 하이픈(-)으로 변환하여 헤더를 추출하고 기록

또한 HTTP 헤더는 대소문자를 구분하지 않으므로 "snake_case"로 알려진 표준 파이썬 스타일로 선언할 수 있습니다.

따라서, User_Agent 등과 같이 첫 문자를 대문자화할 필요없이 파이썬 코드에서처럼 user_agent로 사용합니다.

만약 언더스코어를 하이픈으로 자동 변환을 비활성화해야 할 어떤 이유가 있다면, Header의 convert_underscores 매개변수를 False로 설정

strange_header: Union[str, None] = Header(default=None, convert_underscores=False),
 

 - 중복 헤더 
HTTP 요청에서 같은 이름의 헤더가 여러 번 올 수 있는 경우.

예를 들어 X-Token 헤더가 한 번이 아니라 두 번 이상 올 수 있다.

async def read_items(x_token: Union[List[str], None] = Header(default=None)):

x_token 변수는 리스트(List) 가 됨
헤더가 여러 번 오면 ["값1", "값2", ...] 형태로 들어감
헤더가 없으면 None
 

 

 

-------------------------------------------------------------------------------------------------------------

# 쿠키 매개변수 모델
from fastapi import Cookie, FastAPI

from pydantic import BaseModel

 

class Cookies(BaseModel):

    session_id: str

     fatebook_tracker: str | None = None

     googall_tracker: str | None = None

이렇게 쿠키 매개변수 모델을 작성.

@app.get("/items/")

async def read_items(cookies: Annotated[Cookies, Cookie()]):

Annotated[모델, 의존성 함수] → 모델 구조 + FastAPI 처리 규칙

따라서 Cookies함수가 구조. Cookie()라는 실제 HTTP요청의 쿠키.

 

 - 추가 쿠키 금지하기
class Cookies(BaseModel):

    model_config = {"extra": "forbid"}

------------------------------------------------------------------------------------

# 헤더 매개변수 모델
from fastapi import FastAPI, Header f
rom pydantic import BaseModel

 

class CommonHeaders(BaseModel):

    host: str

    save_data: bool

    if_modified_since: str | None = None

    traceparent: str | None = None

    x_tag: list[str] = []

이렇게 헤더 매개변수 모델을 작성.

@app.get("/items/")

async def read_items(headers: Annotated[CommonHeaders, Header()]):

마찬가지로 Annotated[모델, 의존성 함수] → 모델 구조 + FastAPI 처리 규칙

따라서 CommonHeader 함수가 구조. Header()라는 실제 HTTP요청의 쿠키.

 

- 추가 헤더 금지하기
class CommonHeaders(BaseModel):

    model_config = {"extra": "forbid"}

--------------------------------------------------------------------------------------------------------

# 응답 모델
 response_model : API가 응답할 데이터의 형태를 미리 정의하는 것.

@app.post("/items/", response_model=Item)

response_model은 "데코레이터" 메소드(get, post, 등)의 매개변수입니다.

모든 매개변수들과 본문(body)처럼 경로 작동 함수가 아닙니다.

 

 - 요청(request) 본문과의 차이

요청 본문(request body): 클라이언트가 서버로 보내는 데이터.
예: 사용자가 회원가입 폼을 작성해서 서버에 보내는 JSON.
FastAPI에서는 Body()나 Pydantic 모델로 입력 데이터의 검증과 타입 강제를 할 수 있음.
응답(response): 서버가 클라이언트에게 돌려주는 데이터.
여기서 response_model을 사용하면 서버가 반환할 데이터의 형태를 강제하고, 필요 없는 필드 제거, 타입 변환, 문서화까지 수행.
 -  동일한 입력 데이터 반환
class UserIn(BaseModel):
    username: str

    password: str

async def create_user(user: UserIn) -> UserIn:

비밀번호까지 반환합니다. 혼자 쓸 때는 상관없지만 다른 유저의 요청에도 이렇게 반환할 수도 있기 때문에,

비밀번호 같은 민감한 사항을 모델에 넣지 맙시다.

(절대로 사용자의 평문 비밀번호를 저장하거나 응답으로 발신하지 마십시오.)

 - 출력 모델 추가
대신 평문 비밀번호로 입력 모델을 만들고 해당 비밀번호 없이 출력 모델을 만들 수 있습니다.

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


@app.post("/user/", response_model=UserOut)
이처럼 유저인과 유저아웃을 따로 만들어, 반환이 필요할 시 비밀번호가 빠진 유저 아웃을 이용하면 비밀번호가 포함되지 않은 데이터를 반환.

 

# 응답 모델 인코딩 매개변수

response_model_exclude_unset=True

모델 필드 중 실제로 값이 설정된 것만 반환하고, 기본값(default)이나 None은 생략.
선택적 필드가 많을 때, 불필요하게 긴 JSON 응답을 줄일 수 있음.
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)

 

response_model_include / response_model_exclude

Include: 이 필드만 포함해서 응답.
Exclude: 이 필드만 제외하고 나머지는 응답.
response_model_include={"name", "description"} -> name, description만 반환

response_model_exclude={"tax"} ->  tax만 제외하고 나머지 반환

-------------------------------------------------------------------------------------------------------

# 추가 모델
입력, 출력, DB 모델 분리

UserIn: 클라이언트가 서버에 보내는 데이터 → 비밀번호 포함
UserOut: 클라이언트에게 보내는 응답 데이터 → 비밀번호 제거
UserInDB: 데이터베이스에 저장되는 모델 → 해시된 비밀번호 포함
주의: 절대 평문 비밀번호 저장 X → 반드시 해시 사용

 

 - Pydantic 모델 상속으로 중복 줄이기
 

공통 필드를 가진 UserBase를 만들고, 다른 모델들은 이를 상속
차이점만 추가/제거
class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserIn(UserBase):
    password: str

class UserOut(UserBase):
    pass  # password 없음

class UserInDB(UserBase):
    hashed_password: str

 

 - dict 언패킹으로 모델 간 데이터 변환
 

user_in.dict() → dict로 변환
UserInDB(**user_in.dict(), hashed_password=hashed_password) → 다른 모델로 쉽게 변환 가능
추가 키워드도 같이 전달 가능
user_dict = user_in.dict()
UserInDB(**user_dict, hashed_password=hashed_password)

 

 - Union으로 다양한 타입 응답
 

하나의 경로에서 서로 다른 모델 타입으로 응답 가능
OpenAPI에서는 anyOf로 표현됨
 

response_model=Union[PlaneItem, CarItem]

 

 - 리스트와 dict 타입 응답
 

리스트: response_model=list[Item]
임의 dict: 키/값 타입만 지정 → 유연한 응답 가능
반환할 데이터의 키/값 이름을 미리 모르는 경우

dict로 키/값 타입만 선언 가능.

 

@app.get("/keyword-weights/", response_model=dict[str, float])

 

 

-----------------------------------------------------------------------------------

# 응답 상태 코드
@app.post("/items/", status_code=201)

처럼 응답 코드도 다룰 수 있다.

1xx	정보	거의 안 쓰임, 본문 없음
2xx	성공	200 OK, 201 Created, 204 No Content(본문 없음)
3xx	리다이렉션	304 Not Modified, 본문 있을 수도 있음
4xx	클라이언트 오류	400 Bad Request, 404 Not Found
5xx	서버 오류	500 Internal Server Error
 

 

fastAPI2


pytest

poetry add --group=dev pytest


나는 잘 작동 안하더라.

pass~

# assert <조건>,<오류 메시지>

x = 5
assert x > 0        # True니까 그냥 넘어감
assert x < 0, "x는 0보다 작아야 합니다"  # False → AssertionError 발생

단위 테스트 

def test_get_eta_2024_02_28() -> None: 
    result = get_eta(datetime(2024, 2, 28)) 
    assert result == datetime(2024, 3, 1)

—————————————————————————————————


# 매직 넘버를 쓰지 말자.

# datetime.weekday()
* Python의 datetime 객체에는 요일을 숫자로 반환하는 메서드가 있어
* .weekday()는 0~6 숫자를 반환

예 : 월요일 : 0 …… 일요일: 6


# timedelta

from datetime import timedelta

# 1일
td1 = timedelta(days=1)

# 2시간 30분
td2 = timedelta(hours=2, minutes=30)

# 3주 4일 5시간
td3 = timedelta(weeks=3, days=4, hours=5)


 -  날짜 더하기 / 빼기

from datetime import datetime, timedelta

today = datetime(2025, 8, 19)
tomorrow = today + timedelta(days=1)
yesterday = today - timedelta(days=1)

print(tomorrow)   # 2025-08-20
print(yesterday)  # 2025-08-18

 - 기간 계산
delta = timedelta(days=10)
future = today + delta

 - 그 밖에,,,
d1 = datetime(2025, 8, 19)
d2 = datetime(2025, 8, 25)

diff = d2 - d1
print(diff)           # 6 days, 0:00:00
print(diff.days)      # 6
print(diff.total_seconds())  # 518400.0 (초 단위)

—————————————————————————————————


# coverage

테스트가 실제 코드의 어느 정도를 실행했는지 측정하는 지표.


poetry add --group=dev coverage

테스트 수행

poetry run coverage run -m pytest temp.py

보고서 출력
poetry run coverage report -m

[tool.coverage.run]
omit = ["*/test_*.py"]  # 루트 혹은 루트 아래의 파일들 중 test_ 로 시작하는 파일을 제외.

———————————————————————————————————

# group=dev

종속성은 2가지로 나눌 수 있습니다.
* 서버가 실행되는 중에 필요한 종속성 (예: fastapi, uvicorn, pydantic)
* 개발하는 중에만 필요하고, 서버가 실행되는 도중에는 전혀 사용되지 않는 종속성

종속성을 분리해서 관리하면 쓰지 않을 종족성을 설치하느라 시간가 공간을 낭비할 필요가 없어짐.
특히 ec2 환경보다는 docker 환경에서(kubernetes) 종속성 분리가 빛을 발합니다.
* 매번 업데이트 시마다 docker 이미지를 새로 빌드하는데, 이미지 사이즈 자체가 줄어드니 저장 비용이 감소합니다.
* 매번 배포 시마다 새 이미지를 다운받고 실행하는데, 이때도 사이즈가 작으면 더 빠르게 배포할 수 있습니다.

# EC2 : 클라우드 위에 떠있는 가상 서버
“AWS에서 우분투 서버 하나 빌려서 파이썬 설치하고, 라이브러리 설치하고, 내 앱 돌린다”

# docker : 컨테이너 가상화 기술. 서버 안에서 컨테이너를 만들어 앱과 라이블리 격리시켜 실행.

구분	EC2	Docker
형태	서버 단위	컨테이너 단위
환경 관리	OS/패키지 직접 설치	이미지에 환경 포함
종속성 격리	어렵다	독립적 격리 가능
배포	서버마다 설정 반복	이미지로 동일 환경 배포
저장/업데이트	서버 이미지 크기 큼	컨테이너 이미지 최적화 가능 → 저장 비용↓

def group을 제외하고 설치하기

poetry install --no-root --only main



# 테스트 스크립트 작성

# asyncio 
여러 작업을 동시에 진행하는 것처럼 만들어서, 느린 작업 때문에 프로그램 전체가 멈추는 걸 방지하는 도구
비동기 코드를 실행.

poetry add --group=dev pytest-asyncio

 1. 비동기 함수 정의

async def my_task():

 2. 다른 비동기 함수가 끝날 때까지 기다리지만 그동안 다른 작업은 실행 가능.

await my_task()

 3. event loop
* asyncio의 핵심 구조
* “어떤 작업이 끝나면 다음 작업을 실행” → 작업들을 효율적으로 스케줄링

pyproject.toml 에 옵션 추가

[tool.pytest.ini_options]
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "session"


echo $? : 종전에 exit code 띄움( 보통 0: 성공 / 그 외: 실패)

set -eo pipefail
:스크립트 실행하다 실패하면 더 밑으로 내려가지 마라.

COLOR_GREEN=`tput setaf 2;`
→ 초록색 글씨를 출력할 때 사용할 변수
COLOR_NC=`tput sgr0;` # No Color
→ 색상을 원래대로 되돌리는 변수 (No Color)

즉, 이 변수들을 출력문에 넣으면 글씨 색깔을 바꿀 수 있음.


파일.py에 add()함수 하나.
그리고 test_파일.py에 add()의 테스트를 두면 된다.

# .test.sh
# 안되면 chmod +x .test.sh 
# 그래도 안되면 ./.test.sh

——————————————————————————————————


# github action

.github/workflows/ci.yml
이라는 경로의 폴더를 만들었다고 치자.

name: CI

on:
	push:
:push할때마다 실행하겠다.

jobs:	# 수행할거야.
	static-analysis	# 정적 분석을.
		runs-on:ubuntu-22.04		# 우분투 가상 시스템으로
		steps:
			-name: Check out the codes	# 이름은 체크아웃 코드
			uses: actions/checkout@v2		# 체크아웃 버전투를 이용해서

	teat				# 전체 테스트를.

uses → 실행할 action

with → action 에 전달할 parameter 변수

run → 실행할 명령어

run: | → yaml 문법

 | (파이프라인)을 사용해 value 가 여러 줄(multiline) 이라는 것을 의미



